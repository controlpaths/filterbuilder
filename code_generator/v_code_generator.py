from logger.log_resouce import *

# Write header of verilog file
def write_file_header (module_name, filter_type, filter_response, order, wc, window, beta, coeffs_bits, coeffs_decimal_bits, inout_bits, inout_decimal_bits, axi_stream, verbose):

  log("Writing header.", 'info', verbose)

  header_text = f'/**\n\tFile autogenerated by FilterBuilder tool. https://www.controlpaths.com\
    \n \
    \n\tModule name:\t{module_name}\
    \n\tAuthor:\tFilter Builder tool.\
    \n\tFilter type:\t{filter_type}'
  
  if filter_type == 'fir':
    header_text += f'\n\tFIR Window: \t{window}'

  if filter_type == 'fir' and window == 'kaiser':
    header_text += f'\n\tKaiser beta: \t{beta}'
  
  header_text += f'\n\tFilter order: \t{order}\
    \n\tResponse:\t{filter_response}\
    \n\tFcut:\t{wc}\
    \n\tInput/Output width:\t{inout_bits} bits\
    \n\tInput/Output fractional bits:\t{inout_decimal_bits} bits\
    \n\tCoefficients width:\t{coeffs_bits} bits\
    \n\tCoefficients fractional bits:\t{coeffs_decimal_bits} bits\n'

  if axi_stream:
    header_text += '\tInterface:\tAXI4 Stream\n'
    
  header_text += '**/\n\n'

  return header_text

# write module and port declaration
def write_port_module (module_name, text_reset, inout_bits, axi_stream, verbose):
  log("Writing module declaration.", 'info', verbose)

  port_text = f'module {module_name} (\n\tinput aclk,\n\tinput {text_reset},'
  
  if not(axi_stream):
    port_text += f'\n\n\tinput ce,\n\tinput signed [{inout_bits-1}:0] input_data, /* Input filter data */\n\toutput signed [{inout_bits-1}:0] output_data /* Output filter data */\n);'
  else:
    port_text += f'\n\n\tinput signed [{inout_bits-1}:0] s_axis_tdata, /* Input filter data */\n\tinput s_axis_tvalid,\n\toutput s_axis_tready,\n\n\toutput signed [{inout_bits-1}:0] m_axis_tdata, /* Output filter data */\n\toutput reg m_axis_tvalid,\n\tinput m_axis_tready\n);'

  return port_text

# write coefficient in local parameters
def write_coefficient_parameters (coeffs_bits, quantized_coeffs, verbose):
  log("Writing coefficients.", 'info', verbose)

  # coefficients declared as parameters
  coeffs_text = "\n\n\t/* Coefficients parameters */\n"
  coeff_num = 0
  for param_coeff in quantized_coeffs:
    if param_coeff >= 0:
      coeffs_text = f'{coeffs_text}\tlocalparam signed coeff{coeff_num} = {coeffs_bits}\'d{param_coeff};\n'
    else:
      coeffs_text = f'{coeffs_text}\tlocalparam signed coeff{coeff_num} = -{coeffs_bits}\'d{-param_coeff};\n'
    coeff_num += 1

  return coeffs_text

# write wires and regs of the module
def write_wires_regs (order, coeffs_bits, verbose):
  log("Writing wires and registers declaration.", 'info', verbose)

  # pipeline regs declaration
  wire_and_reg_text = f'\n\t/* Register declaration */'
  
  for current_index in range (0,order+1): 
    wire_and_reg_text += f'\n\treg signed [{coeffs_bits-1}:0] pipe_reg_{current_index}; /* Input pipeline registers declaration */'

  # input and output with internal widths wire declaration
  wire_and_reg_text += f'\n\n\t/* Wires declaration */\n\twire signed [{coeffs_bits-1}:0] input_data_internal; /* Input resized to internal width */\n\twire signed [{coeffs_bits-1}:0] output_data_internal; /* Output resized to internal width */\n' 

  for current_index in range (0,order+1): 
    wire_and_reg_text += f'\twire signed [(2*{coeffs_bits})-1:0] pipe_reg_coeff_{current_index}; /* product result of coeffs x input pipe registers */\n'

  return wire_and_reg_text
  
# write input resize
def write_input_resize (input_data_text, inout_bits, inout_decimal_bits, coeffs_bits, coeffs_decimal_bits, verbose):
  log("Writing input resizing.", 'info', verbose)

  coeffs_integer_bits = coeffs_bits - coeffs_decimal_bits
  inout_integer_bits = inout_bits - inout_decimal_bits

  difference_integer_bits = coeffs_integer_bits - inout_integer_bits
  
  difference_fractional_bits = coeffs_decimal_bits - inout_decimal_bits

  if difference_integer_bits < 0:
    log(f'Number of integer bits of the input/output are greater than integer bits of the coefficient, this result in a negative width. Filter cannot be implemented.', 'error', verbose)

  if difference_fractional_bits < 0:
    log(f'Number of fractional bits of the input/output are greater than fractional bits of the coefficient, this result in a negative width. Filter cannot be implemented.', 'error', verbose)

  resize_text = f'\n\t/* Input data resize to coefficient width */\n\tassign input_data_internal = {{'
  if difference_integer_bits > 0:
    resize_text += f'{{({difference_integer_bits}){{{input_data_text}[{inout_bits-1}]}}}}, '
  
  resize_text += input_data_text
  
  if difference_fractional_bits > 0:
    resize_text += f', {difference_fractional_bits}\'b0'

  resize_text += '};\n'

  return resize_text

# write the register pipeline
def write_pipeline (order, coeffs_bits, ce_text, edge_reset, verbose):
  log("Writing pipeline.", 'info', verbose)

  pipeline_text = f'\n\t/* {order} level pipeline definition */\n\talways@(posedge aclk)\n\t\tif ({edge_reset}) begin'

  for pipe_level in range (0, order+1):
    pipeline_text += f'\n\t\t\tpipe_reg_{pipe_level} <= {coeffs_bits}\'d0;'
  
  pipeline_text += f'\n\t\tend\n\t\telse\n\t\t\tif ({ce_text}) begin\n\t\t\t\tpipe_reg_0 = input_data_internal;'

  for pipe_level in range (1, order+1):
    pipeline_text += f'\n\t\t\t\tpipe_reg_{pipe_level} <= pipe_reg_{pipe_level-1};'

  pipeline_text += '\n\t\t\tend\n'

  return pipeline_text

# write data valid management
def write_management_output_ce (reset_text, axi_stream, verbose):

  if axi_stream:
    log('Creating output data valid management', 'info', verbose)

    managements_output_ce_text = f'\n\t/* Output tvalid management */\n\talways @(posedge aclk)\n\t\tif ({reset_text})\n\t\t\tm_axis_tvalid <= 1\'b0;\n\t\telse\n\t\t\tm_axis_tvalid <= s_axis_tvalid;\n'
  else:
    managements_output_ce_text = ''      

  return managements_output_ce_text

# write MACC structure
def write_macc_structure (order, verbose):
  log("Writing combinational MACC structure.", 'info', verbose)

  macc_text = '\n\t/* MACC Structure */'

  macc_text += f'\n\tassign pipe_reg_coeff_0 = pipe_reg_0 * coeff0;'

  for current_level in range (1, order+1):
    macc_text += f'\n\tassign pipe_reg_coeff_{current_level} = (pipe_reg_{current_level} * coeff{current_level}) + pipe_reg_coeff_{current_level-1};'

  return macc_text

# write output resize
def write_output_resize (order, coeffs_decimal_bits, inout_decimal_bits, output_data_text, verbose):
  log("Writing output resizing.", 'info', verbose)

  output_resize = f'\n\n\tassign output_data_internal = pipe_reg_coeff_{order} >>> {coeffs_decimal_bits};'
 
  output_resize += f'\n\tassign {output_data_text} = output_data_internal >>> {coeffs_decimal_bits - inout_decimal_bits};'

  return output_resize

# verilog fir file creation
def write_verilog_fir_code(file_path, module_name, filter_type, filter_response, order, wc, window, beta, coeffs_bits, coeffs_decimal_bits, inout_bits, inout_decimal_bits, quantized_coeffs, resetn, axi_stream, verbose):
  
  f = open(f'{file_path}', "w")

  log("Generating filter code.",'info', verbose)

  # reset text according reset type
  if resetn:
    text_reset = "resetn"
  else:
    text_reset = "reset"
  
  # edge reset text according reset type
  if resetn:
    edge_reset = "!resetn"
  else:
    edge_reset = "reset"

  # auxiliar definitions
  if not(axi_stream):
    input_data_text = 'input_data' # save this for later
    output_data_text = 'output_data' # save this for later
    ce_text = 'ce'
  else:
    input_data_text = 's_axis_tdata' # save this for later
    output_data_text = 'm_axis_tdata' # save this for later
    ce_text = 's_axis_tvalid'

  # header
  ########
  header_text = write_file_header (module_name, filter_type, filter_response, order, wc, window, beta, coeffs_bits, coeffs_decimal_bits, inout_bits, inout_decimal_bits, axi_stream, verbose)

  # module and port text
  #######################
  port_text = write_port_module (module_name, text_reset, inout_bits, axi_stream, verbose)

  # Coefficient parameters
  ########################
  coeffs_text = write_coefficient_parameters (coeffs_bits, quantized_coeffs, verbose)

  # output ce management
  ######################
  output_ce_text = write_management_output_ce (edge_reset, axi_stream, verbose)

  # pipeline text
  ###############
  pipeline_text = write_pipeline (order, coeffs_bits, ce_text, edge_reset, verbose)

  # wires and regs 
  ################
  wire_and_reg_text = write_wires_regs (order, coeffs_bits, verbose)

  # input resize
  ##############
  resize_text = write_input_resize (input_data_text, inout_bits, inout_decimal_bits, coeffs_bits, coeffs_decimal_bits, verbose)

  # macc text
  ###########
  macc_text = write_macc_structure (order, verbose)

  # output resize
  ###############
  output_resize_text = write_output_resize (order, coeffs_decimal_bits, inout_decimal_bits, output_data_text, verbose)

  end_text = '\n\nendmodule'
  
  log("File creation complete.", 'info', verbose)

  f.write(header_text + port_text + coeffs_text + wire_and_reg_text + resize_text + output_ce_text + pipeline_text + macc_text + output_resize_text + end_text)
  f.close()